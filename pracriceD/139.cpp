#include<iostream>
using namespace std;
long int N;
int main() {
    cin >> N;
    cout << ((N - 1) * N) / 2 << endl;
}

// long int 気をつける！！！！！！
// 整数Nに対して{1, 2, 3, ... N}を並び替えた{P1, P2, ... PN}を選ぶ
// 各i = 1, 2, ..Nについてiをpiで割ったあまりをMiとする
// ΣMiの最大値
// 2 → 1
// 13 →　78
// 1 →　0
//1 <= N <= 10^9

// 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11
// 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 1

//1, 2, 3
//1, 3, 2
//3, 1, 2というてもある
//1+2 = 3

// 1, 2, 3, 4
// 1, 4 ,2 , 3
// 4, 1, 2, 3というてもある
// 1+2+3 = 6

// 1, 2, 3, 4, 5
// 1 ,5 ,2 ,3 , 4
// 5, 1, 2, 3, 4　５という手もある
// 1 + 2 + 3 + 4 = 

//1, 2, 3, 4, 5, 6, 7
//2, 3, 4, 5, 6, 7, 1
//8で考えてみよう
//1, 2, 3, 4, 5, 6, 7, 8
//2, 3, 4, 5, 6, 7, 8, 1
//1, 2, 3, 4, 5, 6, 7, 8, 9
//1, 9, 2, 3, 4, 5, 6, 7, 8
//ここで気づいた偶数の場合と奇数の場合で端っこの処理が変わるんだね

// 気づき列挙
//ある程度のNについて素数番目は必ずあまりがその数になるハズ
//単純なあまりでいいのか、素因数分解でグループ分けなど必要かどうか
//出来るだけ大きな互いに素な数で組みを作る方がいい
//1のペアは必ず1になる、また2のペアは必ず3に3のペア
//max(x|iと素でx<iを満たす方が好ましい)
//ってかこれ漸化式でかけそうじゃない？？
//二つ並びの数字は互いに素なので

// 1 2 3 .. n-2, n-1, n番目
// 1 3 2 .. n-3, n-2,  n-1 ここで問題はnをどこに置くかということ
//逆順にみていけばn番目にn-1,n-1番目にn-2を置いていくのがいいのは自明
//nはn/2+1におけば最大のあまりを出すことができる
//
//p[N] = P[N - 1]

//1, 2, 3, ...., n - 1
//1, 3, 2, ...., n - 2みたいな感じで最大のあまりを計上している配列があるとする
//1, 2, 3, ...., n - 1, n
//1, 2, 3, ...., n - 2, nこれを追加してうまく並び変えて最大あまりを出したい
//とりあえず
//1, 2, 3, ...., n - 1, n
//1, 2, 3, ...., n - 2, n-1になるのは確定
// n - 1が入って最大余りを出せていたところにnが入って最大あまりを出す？？っていうかn - 1が入っていたところkとしたらk+1に入れるのでも問題ない
//どっちみちans(n) = ans(n - 1) + n - 1 + 1 or 0になるね
//ここで、nまでの合計>n - 1の合計
// ans(n - 1) < ans(n) < ans(n - 1) + n - 1 + (n / 2 - 1)でもこれを差し替えただけだよね？？;
//漸化式を立てるかこの間を二分探索するか
